#+TITLE: Functional Programming and the Lambda Calculus

* Overview
What is functional programming?  Why does it matter?  

* Lambda Calculus
  The Lambda Calculus is 
* Functional Programming Languages
Functional programming languages are languages in which you 
can use functions as first-class objects.  That means that you can assign a 
function to a variable, pass it as a parameter, and perform certain operations
on it.  Some languages, like Haskell are strict in enforcing the restrictions
of pure functional programming, and some are much less so.
** JavaScript
JavaScript is the first mainstream language with closures.
#+BEGIN_SRC javascript -n
// Define the variables
var x = 1, plus1;

plus1 = function (a) {
    return a + 1;
}

// plus1 is now a variable containing an anonymous function
//     that adds 1 to its single argument
//

// Invoke plus1 with argment 1
plus1(1);
#+END_SRC

** Lisp
You define an anonymous function with the lambda keyword. 
(This is using Emacs Lisp).
#+BEGIN_SRC emacs-lisp -n
;; setq defines a local variable and assigns it a value.
(setq x 1)

;; x is now a variable containing the value 1
(setq plus1 (lambda (a) "Add 1 to a" (+ a 1)))

;; plus1 is now a variable containing an anonymous function
;;     that adds 1 to its single argument
;;

;; Invoke plus1 with argment 1
(funcall plus1 1)

;; The result is 2.

;; Note that in Emacs Lisp you cannot just say (plus1 1).
#+END_SRC

#+RESULTS:
: 2

See the emacs lisp documentation on [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Lambda-Expressions.html#Lambda-Expressions][lambdas]] and [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html#Lexical-Binding][closures]].
There are Many flavors of Lisp, but I think the most
important ones are listed below.
- Emacs Lisp
- Scheme
You don't have to use the funcall function in Scheme; you would 
just invoke it like any other function. 
(See [[ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_122.html][An Introduction to Scheme and its Implementation]])

#+BEGIN_SRC scheme -n
(define x 1)
(print "x is now a variable containing the value 1")
(print x)
;; Define, but do not assign, plus1
(define plus1)
(set! plus1 (lambda (a) "Add 1 to a" (+ a 1)))
(print "plus1 is now a variable containing an anonymous function")
(print "      that adds 1 to its single argument")
(print "")
(print "Invoke plus1 with argument x")
(print (plus1 x))(define x 1)
(print "x is now a variable containing the value 1")
(print x)
;; Define, but do not assign, plus1
(define plus1)
(set! plus1 (lambda (a) "Add 1 to a" (+ a 1)))
(print "plus1 is now a variable containing an anonymous function")
(print "      that adds 1 to its single argument")
(print "")
(print "Invoke plus1 with argument x")
(print (plus1 x))
#+END_SRC
This is evaluated by the Scheme interpreter at [[http://repl.it][repl.it]]
#+BEGIN_EXAMPLE
x is now a variable containing the value 1
1
plus1 is now a variable containing an anonymous function
      that adds 1 to its single argument

Invoke plus1 with argument x
2
#+END_EXAMPLE
- Clojure  
#+BEGIN_SRC clojure
(def x 1)
(def plus1)
(def plus1 (fn [a] (+ a 1)))
(plus1 1)
#+END_SRC
http://tryclj.com/
** Groovy
#+BEGIN_SRC groovy -n
def x = 1
def plus1 = { a ->  a + 1 }
plus1(x)
#+END_SRC
** Haskell
Haskell is a strictly functional programming language.  This introduces disadvantages as well as advantages, but it was originally an academic language
** Scala
Scala is another language designed for the JVM, which introduces some functional concepts.
#+BEGIN_SRC scala
var plus1 = (x: Int) => x + 1
plus1(1)
#+END_SRC
* Functions as First-Class Objects
  Callbacks, Hooks, and Ajax
** Callbacks
** State tables
** Hooks
** Asynchronous operations
* Closures
* Combinators
* Recursion
* Lists
* Javascript
* Groovy
* Monads
  Monads are a hot topic in today's programming scene.  They are an 
  escapee from Category Theory, which is a kind of meta-mathemeatics.
** IO monad
Real-world programming requires side-effects, which is a big problem for 
strictly functional languages, like Haskell, that enforce immutability.  
They found a loophole by introducing the IO monad, which can be turned into 
a list of instructions for creating the output.
** Maybe monad
** Promises
* Notes
- [[http://marakana.com/s/post/1118/jquery_plugins][Develop your own jQuery plugin]]
- [[http://marakana.com/s/post/1127/jquery_web_page_presentation][Transform your web page into a presentation with jQuery]]
